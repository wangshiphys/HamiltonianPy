"""
Calculate the retarded Green-Function of a finite-size system

The cluster retarded Green-Function is a matrix with shape (N, N) where N is
the number of single-particle-state belong the system. If Numbu
representation is involved, the shape should be (2N, 2N)

The matrix entry:
  G_AB(omega) = <GS|A^dag M_0^-1 B^dag|GS> + <GS|B^dag M_1^-1 A^dag|GS>
  M_0 = omega + GE - H, M_1 = omega - GE + H

  `_` and `^` means subscript and superscript respectively
  `^dag` means the Hermitian conjugate of an operator
  `^-1` means the inverse of an operator
  A, B are creation and/or annihilation operators
  H is the model Hamiltonian, |GS> the ground state and GE the ground
  state energy

  All `A` operators as well as their indices are specified by the
  `row_aoc_indices_table` parameter of these public functions;
  All `B` operators are generated by taken Hermitian conjugate of `A`
  operators and the index of A^dag is the same as A

  Generally, there are two possible case:
    1. Numbu representation involved:
      As = [C_0, C_1, ..., C_{N-1}, A_0, A_1, ..., A_{N-1}]
      Bs = [A_0, A_1, ..., A_{N-1}, C_0, C_1, ..., C_{N-1}]
    2. Numbu representation not involved:
      As = [C_0, C_1, ..., C_{N-1}]
      Bs = [A_0, A_1, ..., A_{N-1}]
    where `C_i` means creation operator and `A_i` means annihilation operator
"""


from scipy.sparse.linalg import eigsh

import numpy as np

from HamiltonianPy.lanczos import Lanczos


__all__ = [
    "ClusterGFSolver",
    "ParticleConservedExactSolver",
    "ParticleNotConservedExactSolver",
    "ParticleConservedLanczosSolver",
    "ParticleNotConservedLanczosSolver",
]


# Calculate the matrix representation of the model Hamiltonian
def _HMatrixGenerator(
        HTerms, state_indices_table, bases, threads_num=1, toarray=False
):
    HM = 0.0
    for term in HTerms:
        HM += term.matrix_repr(
            state_indices_table, bases, threads_num=threads_num
        )
    HM += HM.getH()
    if toarray:
        HM = HM.toarray()
    return HM


# Generate the template for calculating the cluster Green-Function exactly
def _ClusterGFExactSolverTemplate(row_aoc_indices_table, excited_states):
    GFTemplate = []
    for row_index, row_aoc in row_aoc_indices_table:
        bra0_dual = excited_states[row_aoc]
        ket1 = excited_states[row_aoc.dagger()]
        for col_index, col_aoc_dagger in row_aoc_indices_table:
            ket0 = excited_states[col_aoc_dagger]
            bra1_dual = excited_states[col_aoc_dagger.dagger()]
            GFTemplate.append(
                (row_index, col_index, bra0_dual, ket0, bra1_dual, ket1)
            )
    return GFTemplate


# Calculate the cluster Green-Function based on Lanczos projection data
def _ClusterGFLanczosSolverCore(
        omega, GE, GFDim, row_aoc_indices_table,
        krylov_reprs_matrix, krylov_reprs_vectors
):
    ket0s = {}
    ket1s = {}
    omega0 = omega + GE
    omega1 = omega - GE
    for aoc in row_aoc_indices_table.objects():
        ket = krylov_reprs_vectors[aoc][aoc]
        M = krylov_reprs_matrix[aoc]
        I = np.identity(M.shape[0])
        ket0s[aoc] = np.linalg.solve(omega0 * I - M, ket)

        aoc_dagger = aoc.dagger()
        ket = krylov_reprs_vectors[aoc_dagger][aoc_dagger]
        M = krylov_reprs_matrix[aoc_dagger]
        I = np.identity(M.shape[0])
        ket1s[aoc_dagger] = np.linalg.solve(omega1 * I + M, ket)

    gf = np.zeros((GFDim, GFDim), dtype=np.complex128)
    for i, row_aoc in row_aoc_indices_table:
        row_aoc_dagger = row_aoc.dagger()
        ket1 = ket1s[row_aoc_dagger]
        for j, col_aoc_dagger in row_aoc_indices_table:
            col_aoc = col_aoc_dagger.dagger()
            ket0 = ket0s[col_aoc_dagger]
            bra0_dual = krylov_reprs_vectors[col_aoc_dagger][row_aoc]
            bra1_dual = krylov_reprs_vectors[row_aoc_dagger][col_aoc]
            gf[i, j] += np.vdot(bra0_dual, ket0) + np.vdot(bra1_dual, ket1)
    return gf


def ParticleNotConservedExactSolver(
        HTerms, state_indices_table, bases,
        row_aoc_indices_table, *, threads_num=1
):
    """
    Calculate the retarded Green-Function of a finite-size system exactly

    The particle number of the system is not conserved

    Parameters
    ----------
    HTerms : sequence of ParticleTerm instances
        All terms of the model Hamiltonian
    state_indices_table : IndexTable
        A table that associate instances of StateID with integer indices.
        This parameter is passed to the `matrix_repr` method of `AoC` and
        `ParticleTerm` class.
    bases : 1D np.ndarray
        The bases of the Hilbert space
    row_aoc_indices_table : IndexTable
        A table that associate instances of AoC with integer indices
        See also the document of this module
    threads_num : int, keyword-only, optional
        The number of threads to use for calculating the Hamiltonian matrix
        as well as the excited states. This parameter is passed to the
        `matrix_repr` method of `AoC` and `ParticleTerm` class.
        default: 1

    Returns
    -------
    cluster_gf_solver : function
        A function which take the `omega` parameter and calculate the
        corresponding cluster Green-Function G(omega).
    """

    HM = _HMatrixGenerator(
        HTerms, state_indices_table, bases, threads_num, toarray=True
    )
    values, vectors = np.linalg.eigh(HM)
    GE = values[0]
    GS = vectors[:, [0]]
    del values, vectors

    aocs = set()
    for aoc in row_aoc_indices_table.objects():
        aocs.add(aoc)
        aocs.add(aoc.dagger())

    excited_states = {
        aoc: aoc.matrix_repr(
            state_indices_table, bases, threads_num=threads_num
        ).dot(GS) for aoc in aocs
    }
    del GS, aocs

    GFDim = len(row_aoc_indices_table)
    I = np.identity(HM.shape[0], dtype=np.complex128)
    GFTemplate = _ClusterGFExactSolverTemplate(
        row_aoc_indices_table, excited_states
    )

    def ClusterGF(omega):
        gf = np.zeros((GFDim, GFDim), dtype=np.complex128)
        M0 = np.linalg.inv((omega + GE) * I - HM)
        M1 = np.linalg.inv((omega - GE) * I + HM)
        for i, j, bra0_dual, ket0, bra1_dual, ket1 in GFTemplate:
            gf[i, j] += np.vdot(bra0_dual, M0.dot(ket0))
            gf[i, j] += np.vdot(bra1_dual, M1.dot(ket1))
        return gf

    return ClusterGF


def ParticleConservedExactSolver(
        HTerms, state_indices_table, bases_h, bases, bases_p,
        row_aoc_indices_table, *, threads_num=1
):
    """
    Calculate the retarded Green-Function of a finite-size system exactly

    The particle number of the system is conserved

    Parameters
    ----------
    HTerms : sequence of ParticleTerm instances
        All terms of the model Hamiltonian
    state_indices_table : IndexTable
        A table that associate instances of StateID with integer indices.
        This parameter is passed to the `matrix_repr` method of `AoC` and
        `ParticleTerm` class.
    bases : 1D np.ndarray
        The bases of the Hilbert space with M Fermions
    bases_h : 1D np.ndarray
        The bases of the Hilbert space with (M - 1) Fermions
    bases_p : 1D np.ndarray
        The bases of the Hilbert space with (M + 1) Fermions
    row_aoc_indices_table : IndexTable
        A table that associate instances of AoC with integer indices
        See also the document of this module
    threads_num : int, keyword-only, optional
        The number of threads to use for calculating the Hamiltonian matrix
        as well as the excited states. This parameter is passed to the
        `matrix_repr` method of `AoC` and `ParticleTerm` class.
        default: 1

    Returns
    -------
    cluster_gf_solver : function
        A function which take the `omega` parameter and calculate the
        corresponding cluster Green-Function G(omega).
    """

    HM = _HMatrixGenerator(
        HTerms, state_indices_table, bases, threads_num, toarray=True
    )
    values, vectors = np.linalg.eigh(HM)
    GE = values[0]
    GS = vectors[:, [0]]
    del HM, values, vectors

    excited_states = {}
    for creator in row_aoc_indices_table.objects():
        annihilator = creator.dagger()
        excited_states[creator] = creator.matrix_repr(
            state_indices_table, bases,
            left_bases=bases_p, threads_num=threads_num
        ).dot(GS)
        excited_states[annihilator] = annihilator.matrix_repr(
            state_indices_table, bases,
            left_bases=bases_h, threads_num=threads_num
        ).dot(GS)
    del GS

    HM_P = _HMatrixGenerator(
        HTerms, state_indices_table, bases_p, threads_num, toarray=True
    )
    HM_H = _HMatrixGenerator(
        HTerms, state_indices_table, bases_h, threads_num, toarray=True
    )
    I_P = np.identity(HM_P.shape[0], dtype=np.complex128)
    I_H = np.identity(HM_H.shape[0], dtype=np.complex128)

    GFDim = len(row_aoc_indices_table)
    GFTemplate = _ClusterGFExactSolverTemplate(
        row_aoc_indices_table, excited_states
    )

    def ClusterGF(omega):
        gf = np.zeros((GFDim, GFDim), dtype=np.complex128)
        M_P = np.linalg.inv((omega + GE) * I_P - HM_P)
        M_H = np.linalg.inv((omega - GE) * I_H + HM_H)
        for i, j, bra0_dual, ket0, bra1_dual, ket1 in GFTemplate:
            gf[i, j] += np.vdot(bra0_dual, M_P.dot(ket0))
            gf[i, j] += np.vdot(bra1_dual, M_H.dot(ket1))
        return gf

    return ClusterGF


def ParticleNotConservedLanczosSolver(
        HTerms, state_indices_table, bases,
        row_aoc_indices_table, *, threads_num=1, numbu=False
):
    """
    Calculate the retarded Green-Function of a finite-size system based on
    Lanczos projection algorithm

    The particle number of the system is not conserved

    Parameters
    ----------
    HTerms : sequence of ParticleTerm instances
        All terms of the model Hamiltonian
    state_indices_table : IndexTable
        A table that associate instances of StateID with integer indices.
        This parameter is passed to the `matrix_repr` method of `AoC` and
        `ParticleTerm` class.
    bases : 1D np.ndarray
        The bases of the Hilbert space
    row_aoc_indices_table : IndexTable
        A table that associate instances of AoC with integer indices
        See also the document of this module
    threads_num : int, keyword-only, optional
        The number of threads to use for calculating the Hamiltonian matrix
        as well as the excited states. This parameter is passed to the
        `matrix_repr` method of `AoC` and `ParticleTerm` class.
        default: 1
    numbu : boolean, keyword-only, optional
        Whether Numbu representation is involved
        default: False

    Returns
    -------
    cluster_gf_solver : function
        A function which take the `omega` parameter and calculate the
        corresponding cluster Green-Function G(omega).
    """

    HM = _HMatrixGenerator(
        HTerms, state_indices_table, bases, threads_num, toarray=False
    )
    (GE, ), GS = eigsh(HM, k=1, which="SA")
    GFDim = len(row_aoc_indices_table)
    lanczos_projector = Lanczos(HM)

    if numbu:
        excited_states = {
            aoc: aoc.matrix_repr(
                state_indices_table, bases, threads_num=threads_num
            ).dot(GS) for aoc in row_aoc_indices_table.objects()
        }
        del GS

        KrylovReprsMatrix, KrylovReprsVectors = lanczos_projector(
            excited_states
        )
        del excited_states
    else:
        excited_states_particle = {}
        excited_states_hole = {}
        for creator in row_aoc_indices_table.objects():
            annihilator = creator.dagger()
            excited_states_particle[creator] = creator.matrix_repr(
                state_indices_table, bases, threads_num=threads_num
            ).dot(GS)
            excited_states_hole[annihilator] = annihilator.matrix_repr(
                state_indices_table, bases, threads_num=threads_num
            ).dot(GS)
        del GS

        tmp0, tmp1 = lanczos_projector(excited_states_particle)
        KrylovReprsMatrix, KrylovReprsVectors = lanczos_projector(
            excited_states_hole
        )
        KrylovReprsMatrix.update(tmp0)
        KrylovReprsVectors.update(tmp1)
        del excited_states_particle, excited_states_hole
    del lanczos_projector, HM

    def ClusterGF(omega):
        return _ClusterGFLanczosSolverCore(
            omega, GE, GFDim, row_aoc_indices_table,
            KrylovReprsMatrix, KrylovReprsVectors
        )

    return ClusterGF


def ParticleConservedLanczosSolver(
        HTerms, state_indices_table, bases_h, bases, bases_p,
        row_aoc_indices_table, *, threads_num=1
):
    """
    Calculate the retarded Green-Function of a finite-size system based on
    Lanczos projection algorithm

    The particle number of the system is conserved

    Parameters
    ----------
    HTerms : sequence of ParticleTerm instances
        All terms of the model Hamiltonian
    state_indices_table : IndexTable
        A table that associate instances of StateID with integer indices.
        This parameter is passed to the `matrix_repr` method of `AoC` and
        `ParticleTerm` class.
    bases : 1D np.ndarray
        The bases of the Hilbert space with M Fermions
    bases_h : 1D np.ndarray
        The bases of the Hilbert space with (M - 1) Fermions
    bases_p : 1D np.ndarray
        The bases of the Hilbert space with (M + 1) Fermions
    row_aoc_indices_table : IndexTable
        A table that associate instances of AoC with integer indices
        See also the document of this module
    threads_num : int, keyword-only, optional
        The number of threads to use for calculating the Hamiltonian matrix
        as well as the excited states. This parameter is passed to the
        `matrix_repr` method of `AoC` and `ParticleTerm` class.
        default: 1

    Returns
    -------
    cluster_gf_solver : function
        A function which take the `omega` parameter and calculate the
        corresponding cluster Green-Function G(omega).
    """

    HM = _HMatrixGenerator(
        HTerms, state_indices_table, bases, threads_num, toarray=False
    )
    (GE, ), GS = eigsh(HM, k=1, which="SA")
    del HM

    excited_states_particle = {}
    excited_states_hole = {}
    for creator in row_aoc_indices_table.objects():
        annihilator = creator.dagger()
        excited_states_particle[creator] = creator.matrix_repr(
            state_indices_table, bases,
            left_bases=bases_p, threads_num=threads_num
        ).dot(GS)
        excited_states_hole[annihilator] = annihilator.matrix_repr(
            state_indices_table, bases,
            left_bases=bases_h, threads_num=threads_num
        ).dot(GS)
    del GS

    GFDim = len(row_aoc_indices_table)
    HM_P = _HMatrixGenerator(
        HTerms, state_indices_table, bases_p, threads_num, toarray=False
    )
    HM_H = _HMatrixGenerator(
        HTerms, state_indices_table, bases_h, threads_num, toarray=False
    )
    tmp0, tmp1 = Lanczos(HM_P)(excited_states_particle)
    KrylovReprsMatrix, KrylovReprsVectors = Lanczos(HM_H)(
        excited_states_hole
    )
    KrylovReprsMatrix.update(tmp0)
    KrylovReprsVectors.update(tmp1)

    del excited_states_hole, excited_states_particle, HM_P, HM_H

    def ClusterGF(omega):
        return _ClusterGFLanczosSolverCore(
            omega, GE, GFDim, row_aoc_indices_table,
            KrylovReprsMatrix, KrylovReprsVectors
        )
    return ClusterGF


def ClusterGFSolver(
        HTerms, state_indices_table, bases, row_aoc_indices_table, *,
        lanczos=True, numbu=False, conserved=True, threads_num=1
):
    """
    Calculate the retarded Green-Function of a finite-size system

    Parameters
    ----------
    HTerms : sequence of ParticleTerm instances
        All terms of the model Hamiltonian
    state_indices_table : IndexTable
        A table that associate instances of StateID with integer indices.
        This parameter is passed to the `matrix_repr` method of `AoC` and
        `ParticleTerm` class.
    bases : tuple or list or 1D np.ndarray
        If the `conserved` parameter is False, then `bases` should be 1D
        np.ndarray which is the bases of the Hilbert space;
        If the `conserved` parameter is True, then `bases` should be length-3
        tuple or list. `bases[0]` is the bases of the Hilbert space with
        (M - 1) Fermions, `bases[1]` is the bases of the Hilbert space with M
        Fermions and `bases[2]` is the bases of the Hilbert space with (M + 1)
        Fermions.
    row_aoc_indices_table : IndexTable
        A table that associate instances of AoC with integer indices
        See also the document of this module
    threads_num : int, keyword-only, optional
        The number of threads to use for calculating the Hamiltonian matrix
        as well as the excited states. This parameter is passed to the
        `matrix_repr` method of `AoC` and `ParticleTerm` class.
        default: 1
    lanczos : boolean, keyword-only, optional
        Whether to use the Lanczos algorithm
        If set to True, the Lanczos algorithm is used;
        If set to False, calculate the cluster Green-Function exactly.
        default: True
    numbu : boolean, keyword-only, optional
        Whether Numbu representation is involved
        default: False
    conserved ; boolean, keyword-only, optional
        Whether the number of Fermion is conserved
        default: True

    Returns
    -------
    cluster_gf_solver : function
        A function which take the `omega` parameter and calculate the
        corresponding cluster Green-Function G(omega).
    """

    if lanczos:
        if conserved:
            cluster_gf_solver = ParticleConservedLanczosSolver(
                HTerms, state_indices_table, bases[0], bases[1], bases[2],
                row_aoc_indices_table, threads_num=threads_num
            )
        else:
            cluster_gf_solver = ParticleNotConservedLanczosSolver(
                HTerms, state_indices_table, bases,
                row_aoc_indices_table, threads_num=threads_num, numbu=numbu
            )
    else:
        if conserved:
            cluster_gf_solver = ParticleConservedExactSolver(
                HTerms, state_indices_table, bases[0], bases[1], bases[2],
                row_aoc_indices_table, threads_num=threads_num
            )
        else:
            cluster_gf_solver = ParticleNotConservedExactSolver(
                HTerms, state_indices_table, bases,
                row_aoc_indices_table, threads_num=threads_num
            )
    return cluster_gf_solver
